package org.example

import com.typesafe.config.{Config, ConfigFactory}
import org.apache.log4j.{Level, Logger}
import org.apache.spark.sql.catalyst.dsl.expressions.StringToAttributeConversionHelper
import org.apache.spark.sql.{Column, SparkSession}
import org.apache.spark.sql.expressions.Window
import org.apache.spark.sql.functions.{when, _}
import org.apache.spark.sql.types.{LongType, TimestampType}



import java.time.{LocalDate, LocalDateTime}
import java.time.format.DateTimeFormatter



object question1 extends App {
  // /////////////////////////////////////////////
  // Spark Session
  ///////////////////////////////////////////////
  val spark = SparkSession.builder
    .appName("sapient_questions") // optional and will be autogenerated if not specified
    .master("local[*]") // only for demo and testing purposes, use spark-submit instead
    .getOrCreate

  ///////////////////////////////////////////////
  // Spark configs and initial variables
  ///////////////////////////////////////////////
  val configs: Config = ConfigFactory.load("properties.conf")
  import spark.implicits._

  // Read Input Data (lazy)
  val inputFileQ1 = configs.getString("paths.q1data")
  val inputFileQ2 = configs.getString("paths.q2data")
  val inputFileQ3 = configs.getString("paths.q3data")

  // Output locations
  val outputLocQ2 = configs.getString("paths.q1outlocation")

  val inpDF1 = spark.read
    .option("header", true)
    .csv(s"$inputFileQ1")

  val inpDF2 = spark.read
    .option("header", true)
    .csv(s"$inputFileQ2")

  /*val inpDF3 = spark.read
      .option("header",true)
      .csv(s"$inputFileQ3")*/

  // Logger
  val rootLogger = Logger.getRootLogger
  rootLogger.setLevel(Level.ERROR)

  // Date and Time Variables
  val dateToday = LocalDate.now()
  val TimeToday = LocalDateTime.now()
  val dateFormat = "ddMMYYYY"
  val fmtYear = "YYYY"
  val fmtMonth = "MM"
  val fmtDay = "dd"
  val TimeStampFormat = "ddMMYYYY"

  val formattedDate = dateToday.format(DateTimeFormatter.ofPattern("ddMMYYYY"))
  val formattedTime=  TimeToday.format(DateTimeFormatter.ofPattern("YYYY-MM-dd HH:mm:ss"))
  val tsFormat: String = "2018-01-01T12:15:00Z"
//  val formattedTime1= tsFormat.format(DateTimeFormatter.ofPattern(s"$TimeStampFormat"))

  ////////////////////////////////////
  // Logic for Solution 1
  ////////////////////////////////////
  rootLogger.info("---Solution 1---")
  println("---Solution 1---")
  inpDF1.dropDuplicates("Name", "Age").show()


  ////////////////////////////////////
  // Logic for Solution 2
  ////////////////////////////////////
  val formattedDF2 = UserDefinedFunctions.changeColType(inpDF2,"timestamp","Timestamp")

  val windowSpec = Window.partitionBy("userid").orderBy("timestamp")
  val lagWindowOverTs = lag(col("timestamp"), 1).over(windowSpec)
  val lagRunningWindowOverSession = lag((col("session_id")), 1).over(windowSpec)
  val inputDf2WithPreviousTimestamp= formattedDF2.withColumn("prev_timestamp",lagWindowOverTs)
  val inputDf2WithPreviousTimestampAndDuration = inputDf2WithPreviousTimestamp
                                                   .withColumn("duration",UserDefinedFunctions.sessionDuration(unix_timestamp(col("timestamp")),unix_timestamp(col("prev_timestamp"))).cast("Int"))
                                                   .drop("prev_timestamp").na.fill(Map("duration" -> 0))
                                                   .select("userid","timestamp","duration")
  //Persist
  inputDf2WithPreviousTimestampAndDuration.persist()

  val inputDf2WithSessionId = inputDf2WithPreviousTimestampAndDuration.withColumn("session_id",UserDefinedFunctions.assignSessionId(col("duration")) )

  println("---Solution 2---")
  val q2SolutionDf = inputDf2WithSessionId.drop("duration")
  q2SolutionDf.write.mode("overwrite").parquet(outputLocQ2)
  q2SolutionDf.show(false)
  println(s"---The output to Sol2 has been written to $outputLocQ2---")


  ////////////////////////////////////
  // Logic for Solution 3
  ////////////////////////////////////
  println("---Solution 3---")
  inputDf2WithPreviousTimestampAndDuration.show(false)

  //Number of sessions generated in a day.
//  val totalSessionsGeneratedInADay = q2SolutionDf.groupBy(col("userid"),col("session_id")).count()
//  val CountOfSessionsGeneratedInADay = q2SolutionDf.drop(col("timestamp")).distinct().count()
//  val CountOfSessionsGeneratedInADay = q2SolutionDf.dropDuplicates("userid","session_id").count()
//  println(s"Count of Sessions Generated in a Day (Sol-3-a): $CountOfSessionsGeneratedInADay")

  val q3SolutionDf = inputDf2WithPreviousTimestampAndDuration
                     .withColumn("event_year",to_date(col("timestamp"),"fmtYear"))
                     .withColumn("event_month",to_date(col("timestamp"),"fmtMonth"))
                     .withColumn("event_day",to_date(col("timestamp"),"fmtDay"))

  inputDf2WithPreviousTimestamp.show()
  //Total time spent by a user in a day

  //Total time spent by a user over a month.


  //Un-persist
  inputDf2WithPreviousTimestampAndDuration.unpersist()





}
